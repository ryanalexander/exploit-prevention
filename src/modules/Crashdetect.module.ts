// Invitetrack module.ts
import { Message, MessageEmbed } from "discord.js";
import { CrashCheck, Managers, Module } from "../lib/libaries";
import fs from "fs";
import { getGuildMessage, getMessageRandom, lang } from "../lib/LanguageLib";
import { SyrusGuild } from "../managers/GuildManager";
import { UniqueID } from "nodejs-snowflake";
import http from "https";
const uid = new UniqueID({ returnNumber: false });

module.exports = class extends Module {
  constructor() {
    super("crashdetect", ["messageCreate"]);
    this.isDebug = Managers.Config.debug;
  }

  async onMessageReceive(message: Message, guild: SyrusGuild) {
    if (guild.modules.indexOf("crashdetect") < 0) return;
    if (!(await Managers.GuildManager.doPremiumCheck(message.guild, guild)))
      return;

    if (message.embeds.length > 0 || message.attachments.size > 0) {
      // Check

      let urls: any[] = [];
      let found = false;

      message.embeds.forEach((embed) => {
        if (embed.video && (embed.video.url || embed.url)) {
          let foo = embed.video.url !== null ? embed.video.url : embed.url;
          if (foo === null || foo === undefined) return;
          let parts: string[] = foo.split("/");
          let name = (parts[parts.length] || parts[parts.length - 1]).split(
            "?"
          )[0];
          urls.push({
            url: embed.video.url,
            name: `${uid.getUniqueID()}.${name.split(".")[1] || "mp4"}`,
          });
        }
      });
      message.attachments.forEach((attachment) => {
        urls.push({
          url: attachment.url,
          name: `${uid.getUniqueID()}.${
            attachment.name?.split("?")[0].split(".")[1] || "mp4"
          }`,
        });
      });

      for (var i = 0; i < urls.length && !found; i++) {
        var url: any;
        url = urls[i];

        if (this.isDebug) {
          console.log(`Downloading ${JSON.stringify(url)}`);
        }

        if (!url.name) {
          console.log(url);
          url.name = "temp.mp4";
        }

        try {
          await download(url.url, "./checking/" + url.name);
          if (!fs.existsSync("./checking/" + url.name)) return;
          let crash = await CrashCheck("./checking/" + url.name);
          if (crash) {
            found = true;
            await handleDetect(message, message.guild, url.url);

            if (this.isDebug) {
              console.log(`${url.name} - ${crash.check} - hash ${crash.hash}`);
            }

            switch (guild.detect_action) {
              case 0: // Delete & send quirky message
                console.log(getMessageRandom(lang.messages.detection));
                message.channel.send({
                  content: `${message.author}\n${<string>(
                    getMessageRandom(lang.messages.detection)
                  )}`,
                });
                break;
              case 1: // Delete and resend informing that video may crash them
                message.channel.send({
                  embeds: [<MessageEmbed>new MessageEmbed()
                      .setColor("#ff4654")
                      .setAuthor(
                        message.author.tag,
                        message.author.avatarURL() || undefined
                      )
                      .setTitle("Possible crash video")
                      .setDescription(
                        "The below video may crash your Discord, play at your own risk!\n\n" +
                          url.url
                      )
                      .setFooter(`Sent by ${message.author.id}`)],
                });
                break;
              default:
                // Do nothing
                break;
            }
            if (message.guild && guild.log_channel && guild.log_channel !== 0) {
              let channel = await message.guild.channels.resolve(
                guild.log_channel
              );
              if (channel && channel.isText()) {
                let embed = new MessageEmbed();
                embed.setColor("#ff4654");
                embed.setAuthor(
                  message.author.tag,
                  message.author.avatarURL() || undefined
                );
                embed.setTitle("crash video sent");
                embed.setFooter(`Sent by ${message.author.id}`);
                embed.setDescription(`Link to video:\n${urls[0].url}`);
                channel.send({ embeds: [embed] });
              }
            }
          }
          fs.unlinkSync("./checking/" + url.name);
        } catch (e) {
          console.log(e);
        }
      }
    } else if (this.isDebug) {
      console.log(`Message ${message.id} has no attachments / embeds`);
      console.log(message.embeds);
      console.log(message.content);
    }
  }
};

var handleDetect = async function (message: Message, guild: any, link: String) {
  Managers.SQL.registerOffense(
    message.channel,
    link,
    message.author,
    new Date().getTime() - message.createdTimestamp
  );
  if (!message.deleted) {
    message.delete().catch(() => {
      // Message already deleted
    });
    if (guild.log_channel && guild.log_channel != 0) {
      let channel = await Managers.DiscordClient.channels.fetch(
        guild.log_channel
      );
      channel.send({
        embeds: [
          getGuildMessage(
            lang.messages.logging.badlink_detected,
            message.guild,
            [
              {
                type: "DISCORD_TARGET_MENTION",
                value: message.author.toString(),
              },
              {
                type: "DISCORD_TARGET_ID",
                value: message.author.id,
              },
              {
                type: "ARG_DELETED_URL",
                value: link,
              },
              {
                type: "DISCORD_CHANNEL_MENTION",
                value: message.channel.toString(),
              },
            ]
          ),
        ],
      });
    }
  }
};
var download = async function (url: any, dest: any) {
  if (!fs.existsSync("./checking")) fs.mkdirSync("./checking");
  return new Promise((res, rej) => {
    var file = fs.createWriteStream(dest);
    http
      .get(url, function (response: any) {
        response.pipe(file);
        file.on("finish", function () {
          res(file);
        });
      })
      .on("error", function (err: any) {
        // Handle errors
        fs.unlinkSync(dest);
        rej(err);
      });
  });
};
