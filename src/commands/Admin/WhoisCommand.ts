import { Command, Managers, Utils } from "../../lib/libaries";
import { getGuildMessage, lang } from "../../lib/LanguageLib";
import { GuildMember, Message, MessageEmbed } from "discord.js";

module.exports = class extends Command {
  lookupType: "USER" | "INVITE" | undefined;

  constructor() {
    super({
      name: "whois",
      aliases: ["whois"],
      description: "View information on user",
      category: "admin",
      requiredPerms: ["KICK_MEMBERS"],
    });
    this._execute = this.execute;
  }

  /*
   * ep!whois (INVITE | USER)
   */

  async execute(_member: GuildMember, _content: string, _message: Message) {
    let args = _content.split(" ");
    let user;
    let invite;
    let target;

    target = null;

    if (
      _message.mentions.members !== null &&
      _message.mentions.members.first() !== undefined
    ) {
      // @ts-ignore
      target = _message.mentions.members.first().user.id;
      this.lookupType = "USER";
    } else if (args !== undefined) {
      if (!isNaN(Number(args[1]))) {
        this.lookupType = "USER";
      } else {
        this.lookupType = "INVITE";
      }
      target = args[1];
    } else {
      target = this.getSender().member.id;
      this.lookupType = "USER";
    }

    switch (this.lookupType) {
      case "INVITE":
        try {
          invite = await Managers.SQL.getByInviteCode(
            target,
            _message.guild,
            1
          );
          let discordInvite;
          try {
            discordInvite = await _message.guild?.invites.fetch(target);
          } catch (e) {}
          invite.uses = discordInvite
            ? discordInvite.uses
            : invite.members.length;

          await _message.channel.send({
            embeds: [
              <MessageEmbed>(
                getGuildMessage(lang.messages.whois.invite, this.guild, [
                  {
                    type: "INVITE_CODE",
                    value: `${invite.id}`,
                  },
                  {
                    type: "INVITE_CAUGHT_USES",
                    value: `${invite.uses}`,
                  },
                  {
                    type: "INVITE_CREATOR_MENTION",
                    value: `<@${invite.creator}>`,
                  },
                  {
                    type: "INVITE_CREATOR_TAG",
                    value: `-BROKEN-`,
                  },
                  {
                    type: "INVITE_CREATION_DATE",
                    value: `<t:${
                      discordInvite?.createdTimestamp
                        ? Math.round(discordInvite.createdTimestamp / 1000)
                        : 0
                    }:f> (<t:${
                      discordInvite?.createdTimestamp
                        ? Math.round(discordInvite.createdTimestamp / 1000)
                        : 0
                    }:R>)`,
                  },
                  {
                    type: "PLURAL",
                    value: invite.uses != 1 ? "s" : "",
                  },
                ])
              ),
            ],
          });
        } catch (e: any) {
          if (Managers.Config.debug) console.log(e);
          if (e.code === "INVITE_NOT_FOUND") {
            await _message.channel.send({
              embeds: [
                <MessageEmbed>(
                  getGuildMessage(
                    lang.messages.errors.logging.unknown_invite,
                    this.guild,
                    []
                  )
                ),
              ],
            });
          } else {
            Managers.SQL.storeError(e, "WhoisCommand:INVITE");
            _message.channel.send({ content: "Hmm, something went wrong!" });
          }
        }
        break;
      case "USER":
        try {
          user = await Managers.SQL.getGuildUser(_member.guild, { id: target });

          if (!user) {
            await _message.channel.send({
              embeds: [
                <MessageEmbed>(
                  getGuildMessage(
                    lang.messages.errors.logging.unknown_user,
                    this.guild,
                    []
                  )
                ),
              ],
            });
            return;
          }

          let embed: MessageEmbed = <MessageEmbed>(
            getGuildMessage(lang.messages.whois.member, this.guild, [
              {
                type: "DISCORD_TARGET_TAG",
                value: `${user?.user.username}#${Utils.generic.addLeadingZeros(
                  user?.user.tagline
                )}`,
              },
              {
                type: "DISCORD_TARGET_MENTION",
                value: `<@${user.user_id}>`,
              },
              {
                type: "INVITE_CREATOR_MENTION",
                value: `<@${user.invitee}>`,
              },
              {
                type: "INVITE_CREATOR_TAG",
                value: `${
                  user?.inviteUser.username
                }#${Utils.generic.addLeadingZeros(user?.inviteUser.tagline)}`,
              },
              {
                type: "USER_FIRST_SEEN",
                value: `<t:${Math.round(
                  new Date(user.first_seen).getTime() / 1000
                )}:R>`,
              },
              {
                type: "INVITE_USED",
                value: user.invite,
              },
            ])
          );

          if (!user.invitee || user.invite.indexOf("ACTION") > -1) {
            // Remove fields that show who invited
            let fields = embed.fields;
            fields.splice(
              fields.findIndex((field) => field.name === "Invited by"),
              1
            );
            fields.splice(
              fields.findIndex((field) => field.name === "Invite used"),
              1
            );
            embed.setFooter("Unable to fetch invite data");
            embed.fields = fields;
          }

          await _message.channel.send({
            embeds: [embed],
          });
        } catch (e) {
          Managers.SQL.storeError(e, "WhoisCommand:USER");
          await _message.channel.send({
            embeds: [
              <MessageEmbed>(
                getGuildMessage(lang.messages.errors.generic, this.guild, [])
              ),
            ],
          });
          return;
        }
        break;
      default:
        break;
    }
  }
};
