import {GuildMember, Message, MessageEmbed, User} from "discord.js";
import { getGuildMessage, lang } from "../../lib/LanguageLib";
import { Command, Managers } from "../../lib/libaries";
import { extractTimeframe } from "../../lib/utils";

module.exports = class extends Command {
  constructor() {
    super({
      name: "raid",
      aliases: ["raidprevention", "raidprot"],
      description: "Last resort in the event of a raid",
      category: "admin",
      requiredPerms: ["MANAGE_GUILD"],
      requiredModules: ["raidprevention"],
    });
    this._execute = this.execute;
  }

  async execute(_member: GuildMember, _content: string, _message: Message) {
    let target = _message.guild;
    let workingMessage = await _message.channel.send({
      embeds: [
        <MessageEmbed>getGuildMessage(lang.messages.raid.working, target, []),
      ],
    });
    let timeframe = extractTimeframe(_content);
    let recentJoins = await Managers.GuildManager.getRecentJoins(
      target,
      timeframe
    );

    let similarAccounts:{account1: User, account2: User, similarity: Number}[] = [];

    let users: any[] = [];
    for (let i = 0; i < recentJoins.length; i++) {
      let user = await Managers.DiscordClient.users.fetch(
        recentJoins[i].user_id
      );
      users.push(user);
    }

    users.map((user) => {
      users.map((user2) => {
        if (user2 == user) return;
        let similarityScore = 0;
        if (
          Math.max(user.createdTimestamp, user2.createdTimestamp) -
            Math.min(user.createdTimestamp, user2.createdTimestamp) <
          86400000
        )
          similarityScore += 15;
        if (
          Math.max(user.joinedAt, user2.joinedAt) -
            Math.min(user.joinedAt, user2.joinedAt) <
          86400000
        )
          similarityScore +=
            (Math.max(user.joinedAt, user2.joinedAt) -
              Math.min(user.joinedAt, user2.joinedAt)) *
            0.0000005;
        if (user.username.toLowerCase() == user2.username.toLowerCase())
          similarityScore += 100;
        if (similarity(user.username, user2.username) > 0.8)
          similarityScore += 20 * similarity(user.username, user2.username);
        similarAccounts.push({
          account1: user,
          account2: user2,
          similarity: similarityScore,
        });
      });
    });

    let avgSimilarity: any = 0;
    similarAccounts.map((similarAccount) => {
      avgSimilarity += similarAccount.similarity;
    });
    avgSimilarity = avgSimilarity / similarAccounts.length;
    let similar: User[] = [];
    similarAccounts.filter(acc => acc.similarity > avgSimilarity).forEach(acc => {
      similar.push(acc.account1);
      similar.push(acc.account2);
    });

    // Create text file listing all similar ids
    let similarIds = similar.map(user => user.id);
    let similarIdsFile = "";
    similarIds.forEach(id => {
      similarIdsFile += id + "\n";
    });
    let files:any[] = [];
    files.push({
      attachment: Buffer.from(
          similarIdsFile,
          "utf-8"
      ),
      name: `raid-${new Date().getTime()}.txt`,
    });

    let embed = new MessageEmbed()
      .setTitle("Raid Prevention")
        .addField("Confidence", `${avgSimilarity > 80? "Very": avgSimilarity > 50? "Sort-of": "Not very"}%`)
      .setDescription(
        `${similarIds.length} users identified in potential raid`
      )
      .setColor("#e74620");

    workingMessage.edit({ embeds: [embed], files: files });

    /*

    Managers.DiscordClient.guilds
      .fetch("909724713020973066")
      .then(async (guild: Guild) => {
        let members = await guild.members.fetch();
        members.map((member: GuildMember) => {
          if (member.user.username.indexOf("Darkky") > -1) {
            console.log(`Banning ${member.user.username}`);
            member.ban();
          }
        });
      });
     */

    /*
     * - CATEGORIZE
     */
  }
};

function similarity(s1: String, s2: String) {
  var longer = s1;
  var shorter = s2;
  if (s1.length < s2.length) {
    longer = s2;
    shorter = s1;
  }
  var longerLength = longer.length;
  if (longerLength == 0) {
    return 1.0;
  }
  return (longerLength - editDistance(longer, shorter)) / longerLength;
}
function editDistance(s1: String, s2: String) {
  s1 = s1.toLowerCase();
  s2 = s2.toLowerCase();

  var costs = new Array();
  for (var i = 0; i <= s1.length; i++) {
    var lastValue = i;
    for (var j = 0; j <= s2.length; j++) {
      if (i == 0) costs[j] = j;
      else {
        if (j > 0) {
          var newValue = costs[j - 1];
          if (s1.charAt(i - 1) != s2.charAt(j - 1))
            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
          costs[j - 1] = lastValue;
          lastValue = newValue;
        }
      }
    }
    if (i > 0) costs[s2.length] = lastValue;
  }
  return costs[s2.length];
}
