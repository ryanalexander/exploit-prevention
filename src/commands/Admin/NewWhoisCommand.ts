import { Command, Managers } from "../../lib/libaries";
import { GuildMember, Message, MessageEmbed } from "discord.js";
import { getGuildMessage, lang } from "../../lib/LanguageLib";

module.exports = class extends Command {
  lookupType: "USER" | "INVITE" | undefined;

  constructor() {
    super({
      name: "newis",
      aliases: ["whois"],
      description: "View information on user",
      category: "admin",
      requiredPerms: ["MANAGE_MEMBERS"],
    });
    this._execute = this.execute;
  }

  /*
   * ep!whois (INVITE | USER)
   */

  async execute(_member: GuildMember, _content: string, _message: Message) {
    let args = _content.split(" ");
    let user;
    let invite;
    let target;
    let member;

    target = null;

    if (
      _message.mentions.members !== null &&
      _message.mentions.members.first() !== undefined
    ) {
      // @ts-ignore
      target = _message.mentions.members.first().user.id;
      this.lookupType = "USER";
    } else if (args !== undefined) {
      if (!isNaN(Number(args[1]))) {
        this.lookupType = "USER";
      } else {
        this.lookupType = "INVITE";
      }
      target = args[1];
    } else {
      target = this.getSender().member.id;
      this.lookupType = "USER";
    }

    switch (this.lookupType) {
      case "INVITE":
        try {
          target = await _message.guild?.invites.fetch(target);
          if (!target || !target.guild || !target.inviter) return;
          invite = await Managers.SQL.getByInviteCode(
            target.code,
            target.guild.id,
            1
          );
          await _message.channel.send({
            embeds: [
              <MessageEmbed>(
                getGuildMessage(lang.messages.whois.invite, this.guild, [
                  {
                    type: "INVITE_CODE",
                    value: `${target.code}`,
                  },
                  {
                    type: "INVITE_CAUGHT_USES",
                    value: `${invite.uses}`,
                  },
                  {
                    type: "INVITE_CREATOR_MENTION",
                    value: `${target.inviter}`,
                  },
                  {
                    type: "INVITE_CREATOR_TAG",
                    value: `${target.inviter.tag}`,
                  },
                  {
                    type: "INVITE_CREATION_DATE",
                    value: `<t:${target.createdTimestamp}:r>`,
                  },
                ])
              ),
            ],
          });
        } catch (e) {
          await _message.channel.send({
            embeds: [
              <MessageEmbed>(
                getGuildMessage(
                  lang.messages.errors.logging.unknown_invite,
                  this.guild,
                  []
                )
              ),
            ],
          });
        }
        break;
      case "USER":
        target = await Managers.DiscordClient.users.fetch(target);
        user = await Managers.SQL.getGuildUser(_member.guild, target);
        member = await _member.guild.members.fetch(target);
        let isTracking = this.guild.modules.indexOf("invitetrack") > -1;
        let firstSeen = "Unknown";
        if (user) {
          firstSeen = msToReadableTime(
            new Date().getTime() - new Date(user.first_seen).getTime()
          );
        } else if (member != null && member.joinedTimestamp != null) {
          msToReadableTime(new Date().getTime() - member?.joinedTimestamp);
        } else {
          firstSeen = "Never joined";
        }
        await _message.channel.send({
          embeds: [
            <MessageEmbed>(
              getGuildMessage(lang.messages.whois.member, this.guild, [
                {
                  type: "DISCORD_TARGET_TAG",
                  value: `${target.tag}`,
                },
                {
                  type: "DISCORD_TARGET_MENTION",
                  value: `${target.toString()}`,
                },
                {
                  type: "USER_FIRST_SEEN",
                  value: firstSeen,
                },
                {
                  type: "USER_INVITEE",
                  value: member
                    ? isTracking
                      ? user
                        ? `<@${user.invitee}> (${user.invite})`
                        : "Not tracked"
                      : "Tracking disabled"
                    : "Not in guild",
                },
              ])
            ),
          ],
        });
        break;
      default:
        break;
    }

    function msToReadableTime(t: any) {
      const time = Number(t);
      const second = 1000;
      const minute = second * 60;
      const hour = minute * 60;
      const day = hour * 24;
      const month = day * 28;
      const year = month * 12;

      let years = Math.floor(time / year);
      let months = Math.floor((time / month) % 12);
      let days = Math.floor((time / day) % 28);
      let hours = Math.floor((time / hour) % 24);
      let minutes = Math.floor((time / minute) % 60);
      let seconds = Math.floor((time / second) % 60);

      return (
        (years > 0 ? years + "y " : "") +
        (months > 0 ? months + "mo " : "") +
        (days > 0 ? days + "d " : "") +
        (hours > 0 ? hours + "h " : "") +
        (minutes > 0 ? minutes + "m " : "") +
        seconds +
        "s" +
        " ago"
      );
    }
  }
};
