import { Config, Managers } from "../lib/libaries";
import { Guild, Invite, MessageEmbed, TextChannel, User } from "discord.js";
import { getMessage, lang, Language } from "../lib/LanguageLib";
import { types } from "cassandra-driver";
import Integer = types.Integer;

export type SyrusGuild = {
  snowflake: Number;
  log_channel: any;
  detect_action: Number;
  prefix: string;
  premium: boolean;
  trial_noticed: Integer;
  modules: string[];
};

module.exports = class {
  constructor() {}

  async getGuildOrCreate(guild: Guild): Promise<SyrusGuild> {
    let g = await Managers.SQL.getGuild(guild);
    if (!g) {
      await Managers.SQL.registerGuild(guild);
    } else {
      g.name = guild.name;
      g.modules = (await this.getGuildModules(guild))
        .filter((mod) => mod.enabled)
        .map((mod) => mod.module_name);
      if (Managers.Config.isDev) g.prefix = Managers.Config.dev_prefix;
      return g;
    }
    return await this.getGuildOrCreate(guild);
  }

  async doPremiumCheck(guild: Guild, g: any) {
    if (g.premium || true) {
      return true;
    }
    if (guild.memberCount >= Managers.Config.premium_settings.max_members) {
      if (
        Math.round(
          (Managers.Config.premium_settings.max_age -
            (new Date().getTime() - new Date(g.joined).getTime())) /
            8.64e7
        ) < 1
      ) {
        if (g.trial_notices > Managers.Config.premium_settings.max_notices) {
          this.sendInform(
            guild,
            lang.messages.paywall.large_guild_trial_expired,
            []
          );
          Managers.DiscordClient.channels
            .fetch("821701913237782569")
            .then((chan: TextChannel) => {
              chan.send(
                `Disabled crashdetection for ${guild.name} (${guild.id}) with a size of ${guild.memberCount}`
              );
            });
          Managers.GuildManager.disableModule(guild, "crashdetect");
          return false;
        } else {
          let embed = getMessage(
            lang.messages.paywall.large_guild_finalnotice_trial,
            [
              {
                type: "TRIAL_DETECTIONS_REMAINING",
                value:
                  Managers.Config.premium_settings.max_notices -
                  g.trial_notices +
                  "",
              },
            ]
          );
          if (embed instanceof MessageEmbed)
            guild.publicUpdatesChannel?.send({ embeds: [<MessageEmbed>embed] });
          Managers.SQL.query(
            "UPDATE ep_guilds SET trial_notices = ? WHERE snowflake = ?",
            [g.trial_notices + 1, guild.id],
            { prepare: true }
          );
        }
      } else {
        let embed = getMessage(lang.messages.paywall.large_guild_trial, [
          {
            type: "TRIAL_DAYS_REMAINING",
            value:
              Math.round(
                (Managers.Config.premium_settings.max_age -
                  (new Date().getTime() - new Date(g.joined).getTime())) /
                  8.64e7
              ) + "",
          },
        ]);
        if (embed instanceof MessageEmbed)
          guild.publicUpdatesChannel?.send({ embeds: [<MessageEmbed>embed] });
      }
    }
    return true;
  }

  async getModulesByEvent(guild: Guild, event: String) {
    console.log(guild);
    console.log(event);
    // LIST ALL GUILD MODULES
    // CALL MODULE MANAGER FOR EACH ENABLED MODULE THAT SUBSCRIBES TO EVENT
  }

  async sendInform(
    guild: Guild,
    message: Language.Message,
    replacements: Language.StringReplacement[]
  ) {
    let channel;
    let g = await this.getGuildOrCreate(guild);
    if (guild.publicUpdatesChannel) channel = guild.publicUpdatesChannel;
    if (g.log_channel)
      channel = await Managers.DiscordClient.channels.get(g.log_channel);
    if (channel) await channel.send(getMessage(message, replacements));
  }

  async enableModule(guild: Guild, module: String) {
    let mod_config = Managers.Config.modules.find(
      (mod: any) => mod.name.toUpperCase() === module.toString().toUpperCase()
    );
    if (mod_config.depends) {
      mod_config.depends.forEach((dependency: string) => {
        Managers.SQL.setModule(guild, dependency, true);
      });
    }
    return await Managers.SQL.setModule(guild, module, true);
  }

  async disableModule(guild: Guild, module: String) {
    return await Managers.SQL.setModule(guild, module, false);
  }

  async getGuildModules(
    guild: Guild
  ): Promise<[{ module_name: String; enabled: Boolean }]> {
    let modules = await Managers.SQL.getGuildModules(guild);
    let missing: any[];
    let module_list: string[] = [];
    modules.forEach((module: any) => module_list.push(module.module_name));
    missing = Config.modules.filter(
      (el: any) => !module_list.includes(el.name)
    );
    if (missing.length > 0) {
      await Managers.SQL.registerModules(guild, missing);
      return this.getGuildModules(guild);
    }
    return modules;
  }

  async fetchBulk(guilds: any[], user: any) {
    let guildData: any[] = [];
    guilds.map(async (guildId: any) => {
      guildData.push(
        await Managers.SQL.getGuildUser({ id: guildId.guild_id }, { id: user })
      );
    });
    return guildData;
  }

  async syncInvites(guild: Guild) {
    if (!guild.me?.permissions.has(["MANAGE_GUILD"])) return;
    if (Managers.Config.debug) {
      console.log("Invite tracking enabled for " + guild.id);
    }
    let invites = await guild.invites.cache;
    let vanity = null;
    try {
      vanity = await guild.fetchVanityData();
    } catch (e) {
      return;
    }
    let queries: {
      query: string;
      params: (string | number | null | undefined)[];
    }[] = [];
    invites.forEach((invite: Invite) => {
      if (invite.guild)
        queries.push({
          query:
            "INSERT INTO ep_guild_invites (id, creator, guild, uses) VALUES (?, ?, ?, ?)",
          params: [
            invite.code,
            invite.inviter?.id,
            invite.guild.id,
            invite.uses,
          ],
        });
    });
    if (vanity)
      queries.push({
        query:
          "INSERT INTO ep_guild_invites (id, creator, guild, uses) VALUES (?, ?, ?, ?)",
        params: [guild.id, null, guild.id, vanity.uses],
      });
    if (queries.length > 20) {
      for (let i = 0; i < queries.length / 20; i++)
        Managers.SQL._client.batch(
          queries.splice(i == 0 ? i : i * 20, i == 0 ? 20 : i * 20 + 20),
          { prepare: true }
        );
    } else {
      Managers.SQL._client.batch(queries, { prepare: true });
    }
  }

  async setPremium(guild: Guild, premium: Boolean) {
    return await Managers.SQL.setPremium(guild, premium);
  }

  async setPartner(guild: Guild, partner: string, executor: User) {
    let partnerObj = await Managers.SQL.getPartner(partner);
    if (!partnerObj) return { error: "The specified partner does not exist" };
    return {
      success: await Managers.SQL.setPartner(
        guild,
        partnerObj.partner_name,
        executor
      ),
      partner: partnerObj,
    };
  }

  async setBeta(guild: Guild, beta: Boolean) {
    return await Managers.SQL.setBeta(guild, beta);
  }

  async setPrefix(guild: Guild, prefix: String) {
    await Managers.SQL.setPrefix(guild, prefix);
  }

  async setLogs(guild: Guild, channel: TextChannel | undefined) {
    if (channel != undefined)
      channel.send({
        embeds: [
          <MessageEmbed>(
            new MessageEmbed().addField(
              "Logs channel set",
              "I will now post all detection logs into this channel."
            )
          ),
        ],
      });
    await Managers.SQL.setLogs(guild, channel != undefined ? channel.id : 0);
  }

  async setAction(guild: Guild, action: Number) {
    await Managers.SQL.setAction(guild, action);
  }
};
