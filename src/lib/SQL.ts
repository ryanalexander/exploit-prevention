import { Client } from "cassandra-driver";
import { Guild, GuildMember, Invite, TextChannel, User } from "discord.js";
import { Managers } from "./libaries";
import Snowflake from "./Snowflake";

export default class {
  private config: any;
  private _client: Client;

  constructor() {
    this.config = Managers.Config;
    this._client = new Client({
      contactPoints: [this.config.database.host],
      localDataCenter: "datacenter1",
      keyspace: this.config.database.keyspace,
      credentials: {
        username: this.config.database.username,
        password: this.config.database.password,
      },
      encoding: {
        useBigIntAsLong: false,
        useBigIntAsVarint: false,
      },
    });
  }

  // Getters
  async getGuild(guild: Guild): Promise<any> {
    return (
      await this._client.execute(
        "SELECT * FROM stelch.ep_guilds WHERE snowflake = ? ALLOW FILTERING;",
        [guild.id],
        { prepare: true }
      )
    ).first();
  }

  async getGuildsByUser(user: any) {
    console.log(
      `SELECT guild_id FROM ep_guild_users WHERE user_id = ${user} ALLOW FILTERING;`
    );
    return (
      await this._client.execute(
        "SELECT guild_id FROM ep_guild_users WHERE user_id = ? ALLOW FILTERING;",
        [user],
        { prepare: true }
      )
    ).rows;
  }

  async getPartner(partner: string) {
    return (
      await this._client.execute(
        "SELECT * FROM stelch.ep_partners WHERE partner_name = ? ALLOW FILTERING;",
        [partner],
        { prepare: true }
      )
    ).first();
  }

  async getUser(user: any) {
    return (
      await this._client.execute(
        "SELECT * FROM ep_users WHERE snowflake = ?;",
        [user.id],
        { prepare: true }
      )
    ).first();
  }

  async createFOIRequest(user: User, guild: Guild) {
    let hasExistingRequest = await this._client.execute(
      "SELECT * FROM ep_foi_requests WHERE created >= ? AND user_id = ? ALLOW FILTERING;",
      [Number(new Date()) - 2.592e6, user.id],
      { prepare: true }
    );
    if (hasExistingRequest.rows.length > 0) return false;
    this._client.execute(
      "INSERT INTO ep_foi_requests (id, user_id, acknowledged, completed, created, guild_id, informed) VALUES (?,?,false,false,?,?,false)",
      [Snowflake(), user.id, new Date(), guild.id],
      { prepare: true }
    );
    return true;
  }

  async fetchFOIdone() {
    let done = (
      await this._client.execute(
        "SELECT * FROM ep_foi_requests WHERE informed = false AND completed = true LIMIT 15 ALLOW FILTERING;"
      )
    ).rows;
    let queries: any[] = [];
    done.forEach((row) => {
      queries.push({
        query:
          "UPDATE ep_foi_requests SET informed = true WHERE user_id = ? AND id = ?",
        params: [row.user_id, row.id],
      });
    });
    if (queries.length > 0) this._client.batch(queries, { prepare: true });
    return done;
  }

  async getGuildUser(guild: Guild | { id: any }, user: any) {
    let member: GuildMember | undefined;
    try {
      if (guild instanceof Guild) member = await guild.members.fetch(user.id);
    } catch (e) {
      member = undefined;
    }
    let syUser = await this.getUser({ id: user.id });
    let syMember = (
      await this._client.execute(
        "SELECT * FROM ep_guild_users WHERE user_id = ? AND guild_id = ? ALLOW FILTERING;",
        [user.id, guild.id],
        { prepare: true }
      )
    ).first();
    if (!syMember && member) {
      this.registerGuildUser(member, {
        code: "ACTION.UNKNOWNINVITE",
        inviter: user.id,
      });
      return {
        id: 0,
        first_seen: member.joinedAt,
        guild_id: guild.id,
        invite: "ACTION.UNKNOWNINVITE",
        invitee: user.id,
        user_id: user.id,
        user: syUser,
        inviteUser: syUser,
      };
    } else {
      syMember.user = syUser;
      syMember.inviteUser = syMember.invitee
        ? await this.getUser({ id: syMember.invitee })
        : { username: "unknown", tagline: 0 };
      return syMember;
    }
  }

  async getByInviteCode(code: String, guild: Guild, limit: Number) {
    let invite = (
      await this._client.execute(
        "SELECT * FROM ep_guild_invites WHERE id = ? LIMIT 1 ALLOW FILTERING;",
        [code],
        { prepare: true }
      )
    ).first();
    let query = await this._client.execute(
      "SELECT * FROM ep_guild_users WHERE invite = ? AND guild_id = ? LIMIT ? ALLOW FILTERING;",
      [code, guild.id, limit],
      { prepare: true }
    );
    let reply:
      | {
          id: string;
          creator: Number;
          guild: Number;
          members: any[];
        }
      | undefined;
    let members: {
      id: Number;
      first_seen: string;
      invite: string;
      invitee: Number;
      user_id: Number;
      guild_id: Number;
    }[] = [];
    query.rows.map((member) =>
      members.push({
        id: parseInt(member.id),
        first_seen: member.first_seen,
        invite: member.invite,
        guild_id: parseInt(member.guild_id),
        invitee: parseInt(member.invitee),
        user_id: parseInt(member.user_id),
      })
    );
    reply = {
      id: invite.id,
      creator: parseInt(invite.creator),
      guild: parseInt(invite.guild),
      members: [],
    };
    reply.members = members;
    return reply;
  }

  async getHash(hash: String, t: String = "FILE") {
    if (t == "FILE") {
      let h = (
        await this._client.execute(
          "SELECT * FROM stelch.ep_files WHERE hash = ?;",
          [hash],
          { prepare: true }
        )
      ).first();
      if (h)
        this._client.execute(
          `UPDATE ep_files SET occurrences = ${
            h.occurrences === null ? 2 : h.occurrences + 1
          } WHERE hash = ?`,
          [h.hash]
        );
      return h;
    } else if (t == "URL") {
      let h = (
        await this._client.execute(
          "SELECT * FROM stelch.ep_sites WHERE hash = ?;",
          [hash],
          { prepare: true }
        )
      ).first();
      if (h)
        this._client.execute(
          `UPDATE ep_sites SET occurrences = ${
            h.occurrences === null ? 2 : h.occurrences + 1
          } WHERE hash = ?`,
          [h.hash]
        );
      return h;
    } else {
      console.log("Unknown hash type " + t);
      return null;
    }
  }

  async getGuildModules(guild: Guild) {
    return (
      await this._client.execute(
        "SELECT * FROM ep_guild_modules WHERE guild_id = ? ALLOW FILTERING;",
        [guild.id],
        { prepare: true }
      )
    ).rows;
  }

  async getInvitesForGuild(guild: Guild) {
    return (
      await this._client.execute(
        "SELECT * FROM ep_guild_invites WHERE guild = ? ALLOW FILTERING;",
        [guild.id],
        { prepare: true }
      )
    ).rows;
  }

  async registerModules(guild: Guild, modules: []) {
    let queries: (
      | string
      | { query: string; params?: any[] | { [key: string]: any } | undefined }
    )[] = [];
    modules.forEach(({ enabled, name }) =>
      queries.push({
        query:
          "INSERT INTO ep_guild_modules (id, enabled, guild_id, module_name) VALUES (?, ?, ?, ?)",
        params: [Snowflake(), enabled, guild.id, name],
      })
    );
    return await this._client.batch(queries, { prepare: true });
  }

  async registerOffense(
    channel: TextChannel,
    arg: string,
    user: User,
    detect_time: number
  ) {
    return await this._client.execute(
      "INSERT INTO stelch.ep_offenses (id, attachment, channel_id, detect_time, discord_id, guild_id, time) VALUES (?, ?, ?, ?, ?, ?, ?)",
      [
        Snowflake(),
        arg,
        channel.id,
        detect_time,
        user.id,
        channel.guild.id,
        new Date(),
      ],
      { prepare: true }
    );
  }

  // Setters
  async registerGuild(guild: Guild) {
    return await this._client.execute(
      "INSERT INTO stelch.ep_guilds (snowflake, detect_action, log_channel, prefix, premium, joined, trial_notices) VALUES (?, ?, ?, ?, false, ?, 0)",
      [guild.id, 0, null, Managers.Config.bot_prefix, new Date().getTime()],
      { prepare: true }
    );
  }

  async setPremium(guild: Guild, premium: Boolean) {
    return await this._client.execute(
      "UPDATE stelch.ep_guilds SET premium = ? WHERE snowflake = ?",
      [premium, guild.id],
      { prepare: true }
    );
  }

  async setPartner(guild: Guild, partner: number, executor: User) {
    return await this._client.execute(
      `INSERT INTO stelch.ep_partner_guilds ("guildId", established_by, established_on, "partner") VALUES (?, ?, ?, ?)`,
      [guild.id, executor.id, new Date().getTime(), partner],
      { prepare: true }
    );
  }

  async setBeta(guild: Guild, beta: Boolean) {
    return await this._client.execute(
      "UPDATE stelch.ep_guilds SET beta = ? WHERE snowflake = ?",
      [beta, guild.id],
      { prepare: true }
    );
  }

  async getModule(guild: Guild, module: String) {
    return (
      await this._client.execute(
        "SELECT * FROM ep_guild_modules WHERE guild_id = ? AND module_name = ? ALLOW FILTERING",
        [guild.id, module],
        { prepare: true }
      )
    ).first();
  }

  async setModule(guild: Guild, module: String, state: Boolean) {
    let mod = await this.getModule(guild, module);
    return await this._client.execute(
      "UPDATE ep_guild_modules SET enabled = ? WHERE id = ?",
      [state, mod.id],
      { prepare: true }
    );
  }

  async registerUser(user: User, guild: Guild) {
    return await this._client.execute(
      "INSERT INTO ep_users (snowflake, first_guild, first_seen, tagline, username) VALUES (?, ?, ?, ?, ?)",
      [
        user.id,
        guild.id,
        new Date().getTime(),
        user.discriminator,
        user.username,
      ],
      { prepare: true }
    );
  }

  async registerGuildUser(
    member: GuildMember,
    invite?: null | Invite | { code: string; inviter: { id: Number } }
  ) {
    let exists = await this._client.execute(
      "SELECT * FROM ep_guild_users WHERE user_id = ? ALLOW FILTERING;",
      [member.user.id],
      {
        prepare: true,
      }
    );
    if (exists.rows.length > 0) return {};
    return await this._client.execute(
      "INSERT INTO ep_guild_users (id, first_seen, guild_id, invite, invitee, nickname, user_id) VALUES (?,?,?,?,?,?,?) IF NOT EXISTS ",
      [
        Snowflake(),
        member.joinedAt,
        member.guild.id,
        invite?.code,
        invite?.inviter?.id,
        member.nickname,
        member.user.id,
      ],
      { prepare: true }
    );
  }

  async saveHash(hash: String, result: boolean, t: String = "FILE") {
    if (t == "FILE") {
      return await this._client.execute(
        'INSERT INTO stelch.ep_files (hash, "isCrash", occurrences) VALUES (?, ?, 0)',
        [hash, result],
        { prepare: true }
      );
    } else if (t == "URL") {
      return await this._client.execute(
        'INSERT INTO stelch.ep_sites (hash, "isFlagged", occurrences, first_seen) VALUES (?, ?, 0, ?)',
        [hash, result, new Date()],
        { prepare: true }
      );
    } else {
      console.log("Unknown set hash");
      return null;
    }
  }

  async addAuditEntry(action: String, arg: String, guild: Guild, user: User) {
    return await this._client.execute(
      "INSERT INTO stelch.ep_guild_audit (id, action, arg, guild_id, time, user_id) VALUES (?, ?, ?, ?, ?, ?)",
      [Snowflake(), action, arg, guild.id, new Date(), user.id],
      { prepare: true }
    );
  }

  async setPrefix(guild: Guild, prefix: String) {
    return await this._client.execute(
      "UPDATE stelch.ep_guilds SET prefix = ? WHERE snowflake = ?",
      [prefix, guild.id],
      { prepare: true }
    );
  }

  async setLogs(guild: Guild, channel: Number) {
    return await this._client.execute(
      "UPDATE stelch.ep_guilds SET log_channel = ? WHERE snowflake = ?",
      [channel, guild.id],
      { prepare: true }
    );
  }

  async setAction(guild: Guild, action: Number) {
    return await this._client.execute(
      "UPDATE stelch.ep_guilds SET detect_action = ? WHERE snowflake = ?",
      [action, guild.id],
      { prepare: true }
    );
  }

  async getRecentJoins(guild: Guild, timeframe: number) {
    return (
      await this._client.execute(
        "SELECT * FROM ep_guild_users WHERE guild_id = ? AND first_seen > ? ALLOW FILTERING;",
        [guild.id, new Date().getTime() - timeframe],
        { prepare: true }
      )
    ).rows;
  }

  async purgeUser(user: number) {
    this._client.execute("DELETE FROM ep_users WHERE snowflake = ?", [user], {
      prepare: true,
    });
    this._client.execute(
      "DELETE FROM ep_guild_users WHERE user_id = ?",
      [user],
      { prepare: true }
    );
    this._client.execute("DELETE FROM ep_users WHERE snowflake = ?", [user], {
      prepare: true,
    });
    this._client.execute(
      "DELETE FROM ep_message_log WHERE user_id = ?",
      [user],
      { prepare: true }
    );
    this._client.execute(
      "DELETE FROM ep_offenses WHERE discord_id = ?",
      [user],
      { prepare: true }
    );
    this._client.execute("DELETE FROM ep_guild_invites WHERE id = ?", [user], {
      prepare: true,
    });
    // Different data deletion procedure  - Users agree to separate TOS when signing up with website
    // this data is purged every 6 months, entry only created if they sign into the dashboard
    this._client.execute(
      "UPDATE accounts SET disabled_type = 'INACTIVE' WHERE id = ?",
      [user],
      { prepare: true }
    );
  }

  // Global Ban - Queries

  async getScheduledBans(time_start: Number, time_end: Number) {
    return (
      await this._client.execute(
        "SELECT * FROM ep_global_banlist WHERE created > ? AND created < ? AND active = true ALLOW FILTERING;",
        [time_start, time_end],
        { prepare: true }
      )
    ).rows;
  }
  async addGlobalBan(user: User, reason: String) {
    return (
      await this._client.execute(
        "INSERT INTO ep_global_banlist (id, active, created, discord_id, reason) VALUES (?, ?, ?, ?, ?)",
        [Snowflake(), true, new Date(), user.id, reason],
        { prepare: true }
      )
    ).rows;
  }

  // @ts-ignore
  storeError(e: any, location: String) {
    this._client.execute(
      "INSERT INTO ep_caught_errors (id, code, location, value, time) VALUES (?,?,?,?,?)",
      [Snowflake(), `${e.code}`, location, `${e.stack}`, new Date()],
      { prepare: true }
    );
  }

  saveStatEntry(
    offenses: number,
    guilds: number,
    users: number,
    sites: number,
    total_guilds: number,
    total_cur_guilds: number,
    errors: number,
    messages: number
  ) {
    let date = new Date();
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "OFFENSES", date, offenses],
      { prepare: true }
    );
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "guilds", date, guilds],
      { prepare: true }
    );
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "users", date, users],
      { prepare: true }
    );
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "sites", date, sites],
      { prepare: true }
    );
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "total_guilds", date, total_guilds],
      { prepare: true }
    );
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "total_cur_guilds", date, total_cur_guilds],
      { prepare: true }
    );
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "errors", date, errors],
      { prepare: true }
    );
    this._client.execute(
      "INSERT INTO ep_stats (id, key, time, value) VALUES (?,?,?,?)",
      [Snowflake(), "message", date, messages],
      { prepare: true }
    );
  }

  async query(query: string, params: any[]) {
    return await this._client.execute(query, params, { prepare: true });
  }

  async getClient() {
    return this._client;
  }
}
