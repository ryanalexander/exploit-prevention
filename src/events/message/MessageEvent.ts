import {Managers, Event, CrashCheck} from '../../lib/libaries';
import {Message, MessageEmbed} from 'discord.js';
import fs from "fs";
const http = require('https');

module.exports = class extends Event {
    constructor() {
        super({
            event: "message",
        });
        this._execute = this.execute;
    }

    async execute(message: Message) {
        if(!message.guild) return;
        let guild = await Managers.GuildManager.getGuildOrCreate(message.guild);

        if(message.mentions.has(Managers.DiscordClient.user)) {
            message.reply(`My prefix here is \`${guild.prefix}\``);
            return;
        }

        if(message.content.startsWith(guild.prefix))
            Managers.CommandManager.handle(message, guild);

        if(message.embeds.length > 0 || message.attachments.size > 0) {
            // Check

            let urls:any[] = [];
            let found = false;

            message.embeds.forEach((embed) => {
                if(embed.video && embed.video.url) {
                    urls.push({
                        url: embed.video.url,
                        name: embed.video.url.split("/")[embed.video.url.split("/").length]
                    })
                }
            })
            message.attachments.forEach((attachment) => {
                urls.push({
                    url:attachment.url,
                    name:attachment.name
                })
            })

            for(var i = 0; i < urls.length && !found; i++) {
                var url: any;
                url = urls[i];

                await download(url.url, "./checking/"+url.name);
                let crash = await CrashCheck("./checking/"+url.name);
                if(crash) {
                    found = true;
                    message.delete();

                    if(Managers.Config.debug) {
                        console.log(`${url.name} - ${crash}`)
                    }

                    switch (guild.detect_action) {
                        case 0: // Delete & send quirky message
                            message.reply("Please don't attempt to send crash videos/gifs here.");
                            break;
                        case 1: // Delete and resend informing that video may crash them
                            message.channel.send(new MessageEmbed().setColor("#ff4654").setAuthor(message.author.tag, message.author.avatarURL()||undefined).setTitle("Possible crash video").setDescription("The below video may crash your Discord, play at your own risk!\n\n"+url.url).setFooter(`Sent by ${message.author.id}`))
                            break;
                        default: // Do nothing
                            break;
                    }
                    if(guild.log_channel && guild.log_channel !== 0) {
                        let channel = await message.guild.channels.resolve(guild.log_channel)
                        if(channel && channel.isText()) {
                            let embed = new MessageEmbed();
                            embed.setColor("#ff4654");
                            embed.setAuthor(message.author.tag, message.author.avatarURL()||undefined);
                            embed.setTitle("crash video sent")
                            embed.setFooter(`Sent by ${message.author.id}`);
                            embed.setDescription(`Link to video:\n${urls[0].url}`);
                            channel.send(embed);
                        }
                    }
                }
                fs.unlinkSync("./checking/"+url.name);
            }
        }
    }
}
var download = async function(url:any, dest:any) {
    return new Promise((res, rej) => {
        var file = fs.createWriteStream(dest);
        http.get(url, function(response:any) {
            response.pipe(file);
            file.on('finish', function() {
                res(file);
            });
        }).on('error', function(err:any) { // Handle errors
            fs.unlinkSync(dest);
            rej(err);
        });
    })
};