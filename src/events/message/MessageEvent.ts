import {Managers, Event, CrashCheck} from '../../lib/libaries';
import {Message, MessageEmbed} from 'discord.js';
import fs from "fs";
import {getGuildMessage, getMessageRandom, lang} from "../../lib/LanguageLib";
import urlRegex from "url-regex";
// @ts-ignore
import nvt from "node-virustotal";
const { UniqueID } = require('nodejs-snowflake');
const http = require('https');

const isDebug = Managers.Config.debug;
const uid = new UniqueID({returnNumber: false});

module.exports = class extends Event {
    constructor() {
        super({
            event: "message",
        });
        this._execute = this.execute;
    }

    async execute(message: Message) {
        if(!message.guild || message.author.bot) return;
        try {
            let guild = await Managers.GuildManager.getGuildOrCreate(message.guild);
            Managers.SQL.registerUser(message.author, message.guild);

            if (message.mentions.users.size === 1 && message.mentions.has(Managers.DiscordClient.user.id)) {
                message.reply(`My prefix here is \`${guild.prefix}\``);
                return;
            }

            if (message.content.startsWith(guild.prefix))
                Managers.CommandManager.handle(message, guild);

            if(guild.modules.indexOf("safelink") > -1) {
                // Do link checking
                let links = message.content.toString().match(urlRegex());
                if(links) {
                    for(let i = 0; i < links.length; i++) {
                        let link = links[i]
                        link = extractHostname(link);
                        console.log(`Looking up ${link}`)
                        let hash = nvt.sha256(link);
                        let hash_chk = await Managers.SQL.getHash(hash, "URL");
                        console.log(hash_chk);
                        const defaultTimedInstance = nvt.makeAPI().setKey('5ae370dcca742f687860d26c2a82db278fac3d4f3495795320c65b104ad3afdc');
                        if(hash_chk) {
                            if(hash_chk.isFlagged)
                                handleDetect(message, guild, link);
                            return;
                        }
                        try {
                            defaultTimedInstance.domainLookup(link, (err: any, res: any) => {
                                if (err) {
                                    console.log(err);
                                    return;
                                }
                                res = JSON.parse(res);
                                let votes = res.data.attributes.last_analysis_stats;
                                if(isDebug) {
                                    console.log(JSON.stringify(res));
                                    console.log(votes);
                                }
                                if(votes.malicious > 5)
                                    handleDetect(message, guild, link);
                                Managers.SQL.saveHash(hash, votes.malicious > 5,"URL")
                                if (votes.harmless < votes.malicious) {
                                }
                                return;
                            });
                        }catch(e) {
                            console.log(e);
                        }
                    }
                }
            }

            if(guild.modules.indexOf("crashdetect") < 0) return;
            if(!await Managers.GuildManager.doPremiumCheck(message.guild, guild)) return;

            if (message.embeds.length > 0 || message.attachments.size > 0) {
                // Check

                let urls: any[] = [];
                let found = false;

                message.embeds.forEach((embed) => {
                    if (embed.video && (embed.video.url || embed.url)) {
                        let foo = (embed.video.url!==null?embed.video.url:embed.url)
                        if(foo === null || foo === undefined)return;
                        let parts: string[] = foo.split("/");
                        let name = (parts[parts.length] || parts[parts.length - 1]).split("?")[0];
                        urls.push({
                            url: embed.video.url,
                            name: `${uid.getUniqueID()}.${name.split(".")[1] || "mp4"}`
                        })
                    }
                })
                message.attachments.forEach((attachment) => {
                    urls.push({
                        url: attachment.url,
                        name: `${uid.getUniqueID()}.${attachment.name?.split("?")[0].split(".")[1] || "mp4"}`
                    })
                })

                for (var i = 0; i < urls.length && !found; i++) {
                    var url: any;
                    url = urls[i];

                    if (isDebug) {
                        console.log(`Downloading ${JSON.stringify(url)}`)
                    }

                    if (!url.name) {
                        console.log(url);
                        url.name = "temp.mp4";
                    }

                    try {
                        await download(url.url, "./checking/" + url.name);
                        if (!fs.existsSync("./checking/" + url.name)) return;
                        let crash = await CrashCheck("./checking/" + url.name);
                        if (crash) {
                            found = true;
                            message.delete();

                            if (isDebug) {
                                console.log(`${url.name} - ${crash.check} - hash ${crash.hash}`)
                            }

                            switch (guild.detect_action) {
                                case 0: // Delete & send quirky message
                                    message.reply(getMessageRandom(lang.messages.detection));
                                    break;
                                case 1: // Delete and resend informing that video may crash them
                                    message.channel.send(new MessageEmbed().setColor("#ff4654").setAuthor(message.author.tag, message.author.avatarURL() || undefined).setTitle("Possible crash video").setDescription("The below video may crash your Discord, play at your own risk!\n\n" + url.url).setFooter(`Sent by ${message.author.id}`))
                                    break;
                                default: // Do nothing
                                    break;
                            }
                            if (guild.log_channel && guild.log_channel !== 0) {
                                let channel = await message.guild.channels.resolve(guild.log_channel)
                                if (channel && channel.isText()) {
                                    let embed = new MessageEmbed();
                                    embed.setColor("#ff4654");
                                    embed.setAuthor(message.author.tag, message.author.avatarURL() || undefined);
                                    embed.setTitle("crash video sent")
                                    embed.setFooter(`Sent by ${message.author.id}`);
                                    embed.setDescription(`Link to video:\n${urls[0].url}`);
                                    channel.send(embed);
                                }
                            }
                        }
                        fs.unlinkSync("./checking/" + url.name);
                    }catch(e) {
                        console.log(e);
                    }
                }
            } else if (isDebug) {
                console.log(`Message ${message.id} has no attachments / embeds`)
                console.log(message.embeds)
                console.log(message.content)
            }
        }catch (e) {
            console.log(e);
        }
    }
}

function extractHostname(url: String) {
    var hostname;
    //find & remove protocol (http, ftp, etc.) and get hostname

    if (url.indexOf("//") > -1) {
        hostname = url.split('/')[2];
    }
    else {
        hostname = url.split('/')[0];
    }

    //find & remove port number
    hostname = hostname.split(':')[0];
    //find & remove "?"
    hostname = hostname.split('?')[0];

    return hostname;
}
var handleDetect = async function(message: Message, guild: any, link: String) {
    if(!message.deleted) {
        message.delete();
        if(guild.log_channel && guild.log_channel != 0) {
            let channel = (await Managers.DiscordClient.channels.fetch(guild.log_channel))
            channel.send(getGuildMessage(lang.messages.logging.badlink_detected,message.guild,[
                {
                    type: "DISCORD_TARGET_MENTION",
                    value: message.author.toString()
                },
                {
                    type: "DISCORD_TARGET_ID",
                    value: message.author.id
                },
                {
                    type: "ARG_DELETED_URL",
                    value: link
                },
                {
                    type:"DISCORD_CHANNEL_MENTION",
                    value: message.channel.toString()
                }
            ]));
        }
    }
}
var download = async function(url:any, dest:any) {
    if(!fs.existsSync("./checking"))fs.mkdirSync("./checking");
    return new Promise((res, rej) => {
        var file = fs.createWriteStream(dest);
        http.get(url, function(response:any) {
            response.pipe(file);
            file.on('finish', function() {
                res(file);

            });
        }).on('error', function(err:any) { // Handle errors
            fs.unlinkSync(dest);
            rej(err);
        });
    })
};